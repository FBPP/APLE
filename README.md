# 序章：进程相关概念
### 1、程序和进程
+ 程序是文件，在磁盘中
+ 进程是活跃的程序，在内存中
	+ 同一个程序可以运行多个不同的进程
	+ 进程是独立的，每个进程都占用各自的虚拟地址空间
	+ 多个进程的用户区映射到多个物理地址空间，但是内核区只映射到单个物理地址空间，但是多个进程的内核区在虚拟地址空间中并不相同，此功功能是由MMU来实现
	+ 子进程的会使用和父进程相同的代码段
### 2、并发
+ 进程A，B，C ，一个CUP在同一时刻只能运行一个进程
+ 单道程序设计模型 ： A运行完，B运行，B运行完，C运行，C运行完，不是并发的
+ 多道程序设计模型 ： A B C全部运行，每个程序会把自己的计划任务分成多个片段，cpu使用自己的时间轮片，分配给单个进程（A），在运行一个片段后，时钟中断（收回），再分配给其他进程（B），最后A B C 执行完成。 因为cpu的计算速度很快，所以宏观上是并发的
### 3、MMU 
+ 位于cpu中
+ 完成虚拟地址和物理地址的映射
+ 调整cup对内存的访问级别 ： Linux中只有两种级别 ： 用户空间 内核空间
# 第一章：PCB和进程控制块和进程的环境变量
+ PCB位于内核区
+ PCB是一个结构体 类型：task_struct
### 1、PCB的成员
+ 进程id 类型：pid_t 实际上是个unsigned int
+ 进程状态：
	+ 可运行状态 正在运行或者等待被cup运行的进程
	+ 等待状态 当进程等待某个事件（Event）或某个资源时就会进入等待状态，会放弃cup资源，进入等带队列
		+ 可中断等待状态 等带信号 可以被信号唤醒 
		+ 不可中断等待状态  只能用特定的函数去主动唤醒
    + 暂停状态 暂停来接收某些特殊的处理 ，比如调试
    +  僵死状态 进程终止 但是父进程没有执行wait()系统调用，终止进程的信息没有回收
+ 进程切换时需要保存和恢复的cup寄存器的值
	+ 因为cup在切换处理不同的进程时，使用的是同一套寄存机堆，新的进程会覆盖掉旧的进程寄存器中的数据
+ 虚拟地址和物理地址的映射表
+ 描述终端信息 
+ 当前进程的工作目录
+ umask掩码
+ 文件描述符表
+ 和信号相关的信息
+ 用户id和组id
+ 会话和进程组
+ 进程可以使用的资源上限 
	+ ulimit -a 查看资源上限 
+ 详情： https://blog.csdn.net/xyouyubl/article/details/55809313 
### 2、进程的环境变量
+ 引入环境变量 extern char ** environ
+ 是个字符串数组 以NULL作为结尾
+ 位置在高于stack的起始位置
+  getenv() 获取环境变量
+  setenv() 设置/创建 环境变量
+  unsetenv() 删除一个环境变量
# 第二章：进程控制
### 1、进程创建
+ fork() 创建一个子进程 
	+ 子进程拥有和父进程相同的代码段
	+ fork()函数往下的代码父进程和子进程都会执行
	+ fork()只调用了一次，但是会分成两个进程，父进程的返回值会被设置为子进程的pid，子进程的返回值会被设置为0
+ bash通过fork()创建的当前进程
+ 每个进程的执行顺序都不确定，是由cup内核调度算法来决定，可以通过sleep()来控制
### 2、父子进程共享
+ 父子进程的相同之处：全局变量 .text 栈 堆 环境变量 用户id 宿主目录  进程工作目录 信号处理方式
+ 父子不同之处：进程id fork()返回值 父进程id 进程运行时间 闹钟（定时器） 未决信号集
+ 父子的进程共享 ： 文件描述符 mmap建立的映射区
+ 父子进程的相同之处遵从读时共享写时复制，如果对一块内存进行写操作，就会开辟新的区域，否则公用同一块内存
### 3、gdb调试父子进程
+ gdb只能跟踪一个进程 默认跟踪父进程
+ set follow-fork-mode child 命令 设置gdb在fork之后跟踪子进程
+ set follow-fork-mode parent 命令 设置追踪父进程
### 4、exec函数族
+ 执行另一个程序，不会创建新的进程
+ execlp 
	+ 第1个参数是可执行程序名（不需要路径）
	+ 第2个以后的参数为命令行参数，最后以NULL结尾
	+ execlp("ls", "ls", "-l",NULL);
+ execl 第一个参数是路径
	+ 可以加载任意可执行程序
+ execle 最后一个参数传环境变量表
+ execv 第二个参数传命令行参数数组  
+ execvp
+ execve
+ 
+ l 命令行参数，p 搜索file使用path变量 v 使用命令行参数数组 e 使用环境变量数组
+ 
+ exec函数族没有成功返回值，只有失败返回值，调用成功后不会执行后面的代码
# 第三章：回收子进程
+ 正常情况下，子进程结束，父进程会回收子进程占用的资源，
### 1、孤儿进程
+ 当父进程在子进程执行结束前执行结束，该子进程就变成孤儿进程，孤儿进程的父进程就会变成init进程，init被称为孤儿院
### 2、僵尸进程
+ 在子进程执行完成后，父进程没有回收子进程的资源，子进程会留下PCB，子进程就变成一个僵尸进程
+ 父进程结束后会回收僵尸进程
+ kill不能清除僵尸进程，kill只能终止进程，而僵尸进程已经被终止了
+ 使用ps aux可以查看僵尸进程，名字会有[]括起来，而且进程状态是Z+
### 3、wait
+ pid_t wait(int * status);
+ 阻塞等待子进程退出（如果子进程没有结束，父进程会一直等）
+ 成功返回子进程pid，失败（无子进程）返回-1
+ 回收子进程的资源
+ 只能回收一个子进程，那个子进程先结束，就先回收哪个
+ 获取子进程结束状态（退出原因）使用wait的传出参数 int * status
+ WIFEXITD(status) != 0 进程正常退出，可使用下面的宏来获取进程的退出状态
	+ WEXITSTATUS（status）
+ WIFSIGNALED(status) != 0 进程异常终止，可使用下面的宏来来取得终止信号
	+ WTERMSIG(status)
+ WIFSTOPPED(status) != 0 进程处于暂停状态
	+ WSTOPSIG(status) 取得暂停信号
+ WIFCONTINUED（status）!= 0 进程暂停后继续运行  
### 4、waitpid
+ pid_t waitpid(pid_t pid, int * status, int options);
+ 成功返回回收子进程的pid 失败 返回 -1
+ 第一个参数 pid 
	+ pid > 0 指定回收子进程的pid
	+ -1 回收任意子进程（相当于 wait）
	+ 0 回收和当前调用 waitpid 一个组的所有子进程
	+ < -1 回收指定进程组内的任意子进程
		+ 使用ps ajx 可以查看 进程组id（PGID）+ 使用 -进程组id 这个参数可以回收指定组内的任意子进程
		+ 使用 kill -9 -进程组id 可以杀死整个组的进程
+ 第三个参数 可以指定父进程阻塞或不阻塞
	+ 如果设置为WNOHANG 不阻塞 ， 0 阻塞
	+ 如果设置为WNOHANG 
		+ 如果没有执行完的子进程 返回0
		+ 如果有执行完的子进程 返回该进程的pid
		+ 如果没有子进程 返回 -1
# 第四章： 管道
### 1、管道（匿名）
+ 一般指匿名管道
+ 管道只作用于有血缘关系的进程之间
+ 管道的性质
	+ 是一个伪文件，实质是内核缓存区
	+ 由两个文件描述符引用，一个表示读端，一个表示写端
	+ 规定数据从管道的写端流入，读端流出
	+ 管道的读写是阻塞的
+ 管道的原理，内核使用环形队列机制，借助内核缓冲区实现，默认大小4KB
+ 管道的局限性
	+ 一端不能读自己写的数据
	+ 数据一旦被读走，便不存在，不可反复读
	+ 半双工通信，一边读，另一边只能写
	+ 只能在有公共祖先（血缘关系）的进程间使用管道
### 2、创建匿名管道 pipe()
+ int pipe(int pipefd[2])
+ 成功返回 0 ，失败返回 -1 
+ 传出参数中 pipfd[0] : 读端， pipfd[1] : 写端
+ 每个进程拥有各自的pipefd[],里面是两个文件描述符，父进程在调用pipe()后，会在文件描述符表中保存pipefd[0] 和 pipefd[1]
+ fork()一定要在pipe()之后调用，才可以让父子进程通信，并且子进程也会自动保存pipefd[0] 和 pipefd[1]
+ 读端需要close(f[1])，写端需要close(f[0])
+ 如果父读子写，再想让父写子读，需要创建另一个管道
+ 兄弟之间通信，关闭父进程读和写的文件描述符
### 3、管道的读写行为
+ 管道读写的阻塞是因为文件的阻塞,管道是默认阻塞的伪文件
+ 读操作
	+ 有数据
		+ read()正常读，返回读出的字节数
	+ 无数据
		+ 写端全部关闭
			+ read()解除阻塞，返回0
			+ 相当于读文件读到尾部
		+ 写端没有全部关闭
			+ read()阻塞
+ 写操作
	+ 读端全部关闭
		+ 管道破裂，进程停止
			+ 内核给当前进程发信号SIGPIPE终止进程 
	+ 读端没有被全部关闭
		+ 缓冲区写满
			+ write()阻塞
		+ 缓冲区没满
			+ write()继续写
### 4、查看管道大小
+ ulimit -a 查看管道的缓冲区大小，也可以查看很多的虚拟地址空间的信息，比如栈大小，最大支持的文件描述符的个数
+ fpathconf 查看缓冲区大小，也可以查看很多文件的额信息，比如目录最长路径和文件名最大长度
### 5、设置管道读写非阻塞
+ 设置读端非阻塞 pipe(fd)
	+ fcntl() -变参函数，可以修改文件的属性flags（阻塞和非阻塞）
+ 方法
	+ 获取文件的flags
		+ int flags = fcntl(fd[0],F_GETFL);
	+ 将flags修改为非阻塞
		+ flags |= O_NONBLOCK
	+ 将修改后的flags设置回去
		+ fcntl(f[0],F_SETFL,flags);  
### 6、有名管道
+ 特点：
	+ 在磁盘上有一个文件，但是这个文件的大小一直是0，使用ls -l 可以查看 类型为p
	+ 在内核有一个缓存区
	+ 半双工
+ 使用场景
	+ 没有血缘关系的进程间通信
+ 创建方式
	+ 命令 mkfifo 管道名
	+ 函数 mkfifo(const char * pathname, mode_t mode)
+ fifo的使用方法和文件相同，使用open() close() read() write()（但是它和普通文件不同）

# 第五章：内存映射区
### 1、mmap()
+ mmap() 创建内存映射区（它不仅可以用于进程通信）
+ 作用：将磁盘文件的数据映射到内存，用户可以通过修改内存就能修改磁盘文件
	+ 映射内存的位置位于虚拟地址的动态库加载区
+ void * mmap
+ (
	+ void * adrr //映射区首地址，由内核指定，传NULL
	+ size_t length //映射区的大小 不能为0
		+ 实际大小是4kb的整数倍，如果指定的不是4k的整数倍，则向上取4kb的整数倍，例 4kb+1byte 映射成 8kb
	+ int prot //映射区操作权限 
		+ PROT_EXEC 执行
		+ PROT_READ 读 
		+ PROT_WRITE 写
		+ PROT_NONE 无
	+ int flages //标志位参数
		+ MAP_SHARED //共享 数据会同步到磁盘
		+ MAP_PRIVATE //私有 数据不会同步到磁盘
		+ MAP_ANON //创建匿名映射区
	+ int fd //映射的文件的文件描述符
		+ open() 获取
	+ off_t offset //映射文件的偏移量
		+ 可以只映射文件的一部分
		+ 必须是4kb的整数倍  
+ ) 
+ 返回值，调用成功，返回映射区的首地址，调用失败，返回MAP_FAILED（值为(void*)-1）
### 2、munmap()
+ 释放内存映射区（必须通过mmap返回的首地址，否则调用失败）
+ int munmap(void * addr, size_t length);
	+ addr 映射区的首地址
	+ length 映射区的长度
### 3、mmap注意事项
+ 在参数为 MAP_SHARED 的条件下，open的权限一定要 >= mmap的权限，否则mmap会调用失败（没有权限）
+ mmap的权限一定要有PROT_READ
+ open的时候O_CREAT一个新的文件，这个文件大小是0，没有空间，所以不能mmap这个文件，但是对这个文件做拓展，让这个文件大小不是0，就可以了
+ 再mmap之后，close掉文件描述符，对映射区的内存没有影响
+ 对ptr越界操作一般会出现段错误，如果这块内存没有被使用，就不会报错，但是是违法的
### 4、有血缘关系的进程使用mmap通信
+ 父子进程的内存映射区是共享的，使用ptr可以对同一块内存进行操作
### 5、mmap的特点
+ 内存映射区不会阻塞，需要考虑数据读取的先后顺序
### 6、创建匿名映射区
+ 用作有血缘关系的进程通信
+ 匿名映射区不需要打开文件（不需要映射文件）
+ mmap的参数
	+ length 设置一个合理的大小
	+ flags一定要|MAP_ANON来指定创建的是一个匿名映射区
	+ fd 传-1即可，表示没有文件描述符

### 7、无血缘关系的进程间通信
+ 不能使用匿名映射区
+ 借助一个磁盘文件创建映射
+ a.c:
	+ int fd = open("hello"，...);
	+ void * ptr = mmap(...fd,0);
	+ 对映射区做读写操作 使用ptr
+ b.c:
	+ int fd1 = open("hello",...);
	+ void * ptr = mmap(...fd1,0);
	+ 对映射区做读写操作 使用ptr


